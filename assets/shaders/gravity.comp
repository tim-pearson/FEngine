#version 430 core
#define PI 3.1415926538

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) buffer transforms{
    mat4 trs[];
};
layout(binding = 1) buffer velocities{
    vec4 vels[];
};


uniform vec3 ubound;
uniform vec3 lbound;
uniform float deltaTime;

const float mass = 1;

float densityToPressure(float density)
{
   const float targeted = 2; 
   const float pressureMultiplier = 500.0f;
   return abs(density - targeted) * pressureMultiplier;
}

float smoothing(float radius, float dst)
{
    if (dst >= radius) return 0;
    float volume = PI * pow(radius, 4) / 6;
    float val = (radius - dst) * (radius - dst);
    return val / volume;
}

float smoothingDerivative(float radius, float dst)
{
    if (dst >= radius)
        return 0.0f;
    float scale = 12 /(pow(radius, 4) * PI);
    return (dst - radius) * scale;

}
float calculateDensity(vec3 point, float radius)
{
    float density = 0;

    for(int i =0 ; i < gl_NumWorkGroups.x; i++)
    {
        vec3 pos = trs[i][3].xyz;
        float dst = length(pos - point);
        float influence = smoothing(radius, dst);
        density += mass * influence;
    }
    return density;
}
float calculateSharedPressure(float a, float b)
{
    return (densityToPressure(a) + densityToPressure(b)) / 2.0f;
}



void main()
{
    // CONSTANTS
    const float restitutionCoeff = 0.9;
    const float g = 9.81;
    const float radius = 1;
    
    //ID
    const uint id = gl_WorkGroupID.x;
    vec4 t = trs[id][3];
    float particuleDensity = calculateDensity(t.xyz, radius);

    vec3 pressure = vec3(0);
    for (int i = 0; i < gl_NumWorkGroups.x; i++)
    {
        if (i == id)
            continue;
        vec3 other = trs[i][3].xyz;
        float dst = length(other.xyz - t.xyz);
        vec3 dir = dst == 0 ? normalize(vec3(1.0f)) : ((other.xyz - t.xyz) / dst);
        float slope = smoothingDerivative(dst, radius);
        float density = calculateDensity(other, radius);
        float sharedPressure = calculateSharedPressure(density, particuleDensity);
        pressure += sharedPressure * dir * slope * mass / density;
    }


    vec4 vel = vels[id];
    //vel += vec4(0.0f, -1.0f, 0.0f, 1.0f) * g * deltaTime;
    vel += vec4(pressure.xyz, 1.0f) * deltaTime / particuleDensity;
    t += vel * deltaTime;

    if( t.x < lbound.x)
    {
       t.x = lbound.x - vel.x * deltaTime; 
       vel.x *= -restitutionCoeff;
    }
    else if( t.x > ubound.x)
    {
       t.x = ubound.x - vel.x * deltaTime; 
       vel.x *= -restitutionCoeff;
    }
    if( t.y < lbound.y)
    {
       t.y = lbound.y - vel.y * deltaTime; 
       vel.y *= -restitutionCoeff;
    }
    else if( t.y > ubound.y)
    {
       t.y = ubound.y - vel.y * deltaTime; 
       vel.y *= -restitutionCoeff;
    }
    t.w = 1;


    vels[id] = vel * 0.999;
    trs[id][3] = t;
}

